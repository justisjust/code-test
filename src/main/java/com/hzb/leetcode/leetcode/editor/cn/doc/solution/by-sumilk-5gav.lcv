> Problem: [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

[TOC]

# 头插法

下面两份代码的思路都是头插法，唯一的区别是：
**第一种方法：** 将需要反转的链表和待生成的链表分隔开，每次遍历待反转的链表，将其节点通过头插法插入到Head后面。Head为left的前驱节点，也就是最后一个不需要被反转的链表。
因为是进行隔开的，因此最后需要把剩下的未反转的链表接到已经反转的链表的尾部，恰好已经反转的链表的尾部节点就是left节点。
**第二种方法：** 没有进行隔开。最后不需要进行拼接。
需要注意的是这种方法中，left节点是固定的，因此只需要头插right - left个节点即可。
这里的pre就是left节点，它是始终固定不动的，唯一在变化的是pre的后继节点，每次这个后继节点被取下通过头插法插入到Head后之后，就将该后继节点的后继节点作为pre的后继节点。

# Code

* []

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 整个链表的虚拟头节点，以防止left为1的情况
        ListNode dummyHead = new ListNode(0, head);
        // Head为left节点的前驱，以方便进行头插法
        ListNode Head = dummyHead;
        int count = 0;
        // 先找到Head节点
        while(count < left - 1) {
            Head = Head.next;
            count++;
        }
        // 将left到right的节点依次通过头插法插入到Head后面
        ListNode p = Head.next; // p就是当前遍历的节点 left
        ListNode tail = p; // 记录尾节点
        for(int i = left; i < right + 1; i++) {
            ListNode temp = p;
            p = p.next;
            temp.next = Head.next;
            Head.next = temp;
        }
        // 把剩下的不需要反转的接上
        tail.next = p;
        return dummyHead.next;

    }
}
```

* []

```Java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 整个链表的虚拟头节点，以防止left为1的情况
        ListNode dummyHead = new ListNode(0, head);
        // Head为left节点的前驱，以方便进行头插法
        ListNode Head = dummyHead;
        int count = 0;
        // 先找到Head节点
        while(count < left - 1) {
            Head = Head.next;
            count++;
        }
        ListNode pre = Head.next; // p就是当前遍历的节点 left
        for(int i = left; i < right; i++) {
            ListNode temp = pre.next;
            pre.next = temp.next;
            temp.next = Head.next;
            Head.next = temp;
        }
        return dummyHead.next;

    }
}
```

时间复杂度：$O(n)$ 只需要遍历一遍链表即可
空间复杂度：$O(1)$ 不需要额外的存储空间，只有一个dummyHead是额外的空间。

> dummyHead是必要的，因为它可以处理left为1的情况。我们始终需要left的前驱作为Head（头插法的头节点）。而left等于1时，就需要dummyHead发挥作用了。

