本题大家应该都能有思路，模拟小时候学的竖版乘法。可能主要是考察编码能力。
我这里分享的实现也没有什么新鲜的地方，也是一样的模拟竖版乘法。只是觉得这样实现性能还不错，顾分享出来，自己也记录一下。
![clipboard.png](https://pic.leetcode-cn.com/1665017106-KInaOU-clipboard.png)

* 

```
class Solution {
    public String multiply(String num1, String num2) {
        // 将数组转化成字符数组
        char[] arr1 = num1.toCharArray();
        char[] arr2 = num2.toCharArray();
        int n = arr1.length, m = arr2.length;
        // 存放结果的数组，长度最多为 m + n 
        int[] res = new int[m + n];
        // 以num2为乘数，num1为被乘数
        // 从右往左，取出num2中的每一位和num1中的每一位相乘
        // 每次相乘得到的结果，直接添加到最后的结果数组中，需要注意进位和结果数组下标
        for(int i = m - 1; i >= 0; i --){
            int index = res.length - 1 - (m - 1 - i);
            int carry = 0;
            // 从右往左，取出num1中的每位
            for(int j = n - 1; j >= 0; j --){
                // 将两个数的乘积结果，直接存入到结果的数组中
                int temp = toNum(arr2[i]) * toNum(arr1[j]) + carry + res[index];
                res[index --] = temp % 10;
                carry = temp / 10;
            }
            // 考虑最后的进位问题
            while(index >= 0 && carry != 0){
                int temp = res[index] + carry;
                res[index --] = temp % 10;
                carry = temp / 10;
            }
        }
        // 拼接结果字符串
        int index = 0;
        // 去除前导0
        while(index < res.length && res[index] == 0){
            index ++;
        }
        StringBuffer buffer = new StringBuffer();
        for( ; index < res.length; index ++){
            buffer.append(res[index]);
        }
        return buffer.length() == 0 ? "0" : buffer.toString();
    }

    private int toNum(char c){
        return c - '0';
    }
}
```

