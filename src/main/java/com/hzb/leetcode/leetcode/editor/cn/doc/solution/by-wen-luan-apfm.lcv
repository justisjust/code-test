# 思路

思路：经典回溯全匹配路径，类似全排列

# 回溯

* 

```
class Solution {

     boolean[][] visited ;
    boolean isExist;
    public boolean exist(char[][] board, String word) {
        visited = new boolean[board.length][board[0].length];

        // 没有说从哪里开始
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                backtrack(0 , i,j,board,word);
            }
        }
        return isExist;
    }

    public void backtrack(int strIndex, int x , int y , char[][] board ,String word){

        // 正确完成终止条件
        if(strIndex == word.length()){
            isExist = true;
            return ;
        }

        //越界和访问 非法 
        if ( x >= board.length || y >= board[0].length || x<0 || y < 0 || visited[x][y]) return;

        // 确认相等后赋予“已访问状态”
        if (board[x][y]== word.charAt(strIndex)){
            visited[x][y] = true;
            backtrack(strIndex+1 , x+1,y,board,word);
            backtrack(strIndex+1 , x-1,y,board,word);
            backtrack(strIndex+1 , x,y+1,board,word);
            backtrack(strIndex+1 , x,y-1,board,word);
            // 撤销已访问状态：此路不通 或者 完成
            visited[x][y] = false;
        }

    }
}
```

