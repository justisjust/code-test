[详细刷题视频合集](https://xiaochen1024.com/series/6196129fc1553b002e57bef5/6196208ec1553b002e57bef6)      
[刷题笔记](https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18)

- 思路：从上到下，左到右遍历网格，每个坐标递归调用`check(i, j, k)`函数，i,j表示网格坐标，k表示word的第k个字符，如果能搜索到第k个字符返回true，否则返回false，check函数的终止条件有2种情况

  1. 如果i，j位置的字符和字符串位置k的字符不相等，则这条搜索路径搜索失败 返回false
  2. 如果搜索到了字符串的结尾，则找到了网格中的一条路径，这条路径上的字符正好可以组成字符串s

  两种情况都不满足则把当前网格节点加入`visited`数组，`visited`表示节点已经访问过了，然后顺着当前网格坐标的四个方向继续尝试，如果没找到k开始的子串，则回溯状态`visited[i] [j] = false`，继续后面的尝试。

- 复杂度分析：时间复杂度`O(MN⋅3^L)`，M,N 为网格的长度与宽度，L 为字符串 word 的长度，第一次调用`check`函数的时候，进行4个方向的检查，其余坐标的节点都是3个方向检查，走过来的分支不会反方向回去，所以`check`函数的时间复杂度是`3^L`，而网格有`M*N`个坐标，且存在剪枝，所以最坏的情况下时间复杂度是`O(MN⋅3^L)`。空间复杂度是`O(MN)`，`visited`数组空间是`O(MN)`，`check`递归栈的最大深度在最坏的情况下是`O(MN)`

##### 方法1:回溯

Js:

* js

```js
var exist = function(board, word) {
    const h = board.length, w = board[0].length;//网格的长和宽
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];//方向数组
    const visited = new Array(h);//标记是否访问过的数组
    for (let i = 0; i < visited.length; ++i) {//初始化visited数组
        visited[i] = new Array(w).fill(false);
    }
    const check = (i, j, s, k) => {//检查从网格i，j出发是否能搜索到0-k的字符组成的子串
      	//如果i，j位置的字符和第k个的字符不相等，则这条搜索路径搜索失败 返回false
        if (board[i][j] != s.charAt(k)) {
            return false;
         //如果搜索到了字符串的结尾，则找到了网格中的一条路径，这条路径上的字符正好可以组成字符串s
        } else if (k == s.length - 1) {
            return true;
        }
        visited[i][j] = true;//标记i，j被访问过了
        let result = false;
        for (const [dx, dy] of directions) {//向i，j的四个方向继续尝试寻找
            let newi = i + dx, newj = j + dy;
            if (newi >= 0 && newi < h && newj >= 0 && newj < w) {//新的坐标位置合法检查
                if (!visited[newi][newj]) {//新的坐标不能存在于visited中，也就是不能是访问过的
                    const flag = check(newi, newj, s, k + 1);//继续检查新的坐标
                    if (flag) {//如果在网格中找到了字符串 则跳过循环
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;//回溯状态
        return result;//返回结果
    }

    for (let i = 0; i < h; i++) {
        for (let j = 0; j < w; j++) {
            const flag = check(i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }
    return false;
};

```

Java:

* java

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int h = board.length, w = board[0].length;
        boolean[][] visited = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {
        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }
}

```

