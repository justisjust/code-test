执行用时： 1 ms , 在所有 Java 提交中击败了 99.79% 的用户

内存消耗： 41.8 MB , 在所有 Java 提交中击败了 97.36% 的用户

简单的全排列，运用了恢复现场的技巧，在动态规划中这个很常见，所以动态规划熟悉了后，写这个就很简单了！

* 

```
public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        process(nums, nums.length, new ArrayList<>(), ans);
        return ans;
    }

    private void process(int[] nums, int rest, List<Integer> temp, List<List<Integer>> ans) {
        if(rest == 0){
            ans.add(temp);
            return;
        }
        List<Integer> newTemp;
        int item;
        for(int i = 0; i < nums.length; i++){
            if(i - 1 >= 0 &&nums[i] == nums[i -1]){
                continue;
            }
            if(nums[i] != Integer.MAX_VALUE){
                item = nums[i];
                newTemp = new ArrayList<>(temp);
                newTemp.add(nums[i]);
                nums[i] = Integer.MAX_VALUE;
                process(nums, rest - 1, newTemp, ans);
                nums[i] = item;
            }
        }
    }
```

