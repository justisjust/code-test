### 解题思路

与[全排列](https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-jing-dian-yun-yong-by-yun-v4ej/)解题思路一致，
加了一步contains去重操作

### 代码

* java

```java
class Solution {
    List<List<Integer>>ans=new ArrayList<>();//存放结果
    List<Integer>path=new ArrayList<>();//存放当前遍历的节点
    public List<List<Integer>> permuteUnique(int[] nums) {
        if(nums.length==0)
        {
            return ans;
        }
        boolean[] used=new boolean[nums.length];
        for(int i=0;i<nums.length-1;i++)
        {
            used[i]=false;
        }
        dfs(nums,used);
        return ans;
    }
    public void dfs(int[] nums,boolean[] used)
    {

        if(path.size()==nums.length)//结束条件:path中的数量==nums的数量
        {   
            if(ans.contains(path))
            {
                return;
            }
            else
            {
                ans.add(new ArrayList<>(path));
                return;
            }
        }
        for(int i=0;i<nums.length;i++)
        {
            if(used[i]==true)
            {
                continue;
            }
            path.add(nums[i]);//做选择
            used[i]=true;
            dfs(nums,used);//进入下一层决策树
            path.remove(path.size()-1);//取消选择
            used[i]=false;
        }
    }

    
}
```

