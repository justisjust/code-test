### 解题思路

此题和全排列1的区别在于数组可能出现重复元素，而返回结果不能有重复
那么只需要做到回溯时相等的元素不在同一个位置使用两次即可，而本题中数组内元素只可能是-10 ~ 10共计21个整数
因此我们可以创建长度为21的int型数组times，然后遍历nums并记录下每个元素可以使用的次数，每个元素n的可使用次数根据下标n + 10查询
然后通过循环判断是否还有剩余可使用次数即可
以元素的值对应times下标可以确保同一个值不可能遍历两次
记录使用次数而非单单记录是否使用过可以确保每一个相等的元素都会被使用不会产生遗漏
21个数字不会每个都出现但没有出现过的元素使用次数始终为0

### 代码

* java

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        // 记录数字剩余使用次数
        int[] times = new int[21];
        for (int num : nums) {
            times[num + 10]++;
        }
        int len = nums.length;
        List<List<Integer>> res = new LinkedList<>();
        LinkedList<Integer> temp = new LinkedList<>();
        dfs(nums, res, temp, times, len, 0);
        return res;
    }
    public void dfs(int[] nums, List<List<Integer>> res, LinkedList<Integer> temp, int[] times, int len, int depth) {
        if (len == depth) {
            res.add(new LinkedList<>(temp));
            return;
        }
        for (int i = 0; i < 21; i++) {
            // 如果使用次数大于0
            if (times[i] > 0) {
                temp.addLast(i - 10);
                times[i]--;
                dfs(nums, res, temp, times, len, depth + 1);
                temp.removeLast();
                times[i]++;
            }
        }
    }
}
```

