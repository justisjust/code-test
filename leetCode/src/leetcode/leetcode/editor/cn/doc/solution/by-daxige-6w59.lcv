### 解题思路

求所有解用遍历，DFS；
注意重复元素要先排序；
每个元素只能使用一次；
重复元素排在后边的先使用的排列可以直接丢弃；

### 代码

* java

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        //解题思路：求所有解用遍历，DFS
        //重复数字需要排序
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList();
        dfs(result, nums, new ArrayList(), new int[nums.length]);
        return result;
    }

    private void dfs(List<List<Integer>> result, int[] nums, List<Integer> path, int[] used){
        if(nums.length == path.size()){
            result.add(new ArrayList(path));
            return;
        }

        for(int i = 0; i < nums.length; i++){
            //相同数字，前边元素还没用就用后边元素的一定会和先用前边的排列重合
            if(i > 0 && nums[i] == nums[i - 1]  && used[i - 1] == 0){
                continue;
            }
            //元素不能重复使用
            if(used[i] != 1){
                path.add(nums[i]);
                used[i] = 1;
                dfs(result, nums, path, used);
                path.remove(path.size() - 1);
                used[i] = 0;
            }
        }
    }
}
```

