### 解题思路

开心，刷过的题终于有用了！<br><br>

### 解法一：

思路：参考“八数码难题”的思路和解法。<br><br>

题意中表明“含重复数字的序列”，言下之意为“dfs过程中可能出现重复的全排列”。可以把每一个全排列当做一种唯一的状态，并把它加入到set中去重。故在递归出口处输出全排列时，对每一个全排列（状态）进行判重，若set中存在该状态，则不加入结果中。否则将状态加入到结果。

* java

```java
class Solution {
    int N = 10;
    int n;
    int[] path = new int[N];
    boolean[] st = new boolean[N];
    HashSet<String> set = new HashSet<>();
    List<List<Integer>> ans = new ArrayList<>();

    public void dfs(int u, int[] nums) {
        if (u == n) {
            List<Integer> tmp = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                tmp.add(path[i]);
            }
            String cur = Arrays.toString(path);
            if (!set.contains(cur)) {
                set.add(cur);
                ans.add(tmp);
            }
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!st[i]) {
                path[u] = nums[i];
                st[i] = true;
                dfs(u + 1, nums);
                st[i] = false;
            }
        }
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        n = nums.length;
        dfs(0, nums);
        
        return ans;
    }
}
```

<br><br>

### 解法二：

回溯+剪枝。!st[i - 1]在于判断相同的数字是不是出现在同一层当中，若出现在同一层说明需要去重，否则不需要去重。

* java

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> perm = new ArrayList<>();
    int n;
    boolean[] st;

    public void dfs(int u, int[] nums) {
        if (u == n) {
            ans.add(new ArrayList<>(perm));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && !st[i - 1])
                continue;
            if (!st[i]) {
                st[i] = true;
                perm.add(nums[i]);
                dfs(u + 1, nums);
                st[i] = false;
                perm.remove(u);
            }
            
        }
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        n = nums.length;       
        st = new boolean[n]; 
        Arrays.sort(nums); // 排序一下
        dfs(0, nums);

        return ans;
    }
}
```

